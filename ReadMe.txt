https://github.com/okovtun/PU_211.git
https://www.youtube.com/watch?v=P-gfKtnSsGQ&list=PLeqyOOqxeiIOrmXJmnyCKSdcyAKXVkYRF

Book:
https://drive.google.com/drive/folders/1PtH0LBlm7PpmBcaE6mwBnkftAcEui32y?usp=sharing

TODO:
Выполнить "Задание 1" из файла: https://github.com/okovtun/PU_211/blob/master/STL/GAI%20DZ_PS_C%2B%2B_nedelya_09.pdf

DONE:
1. В ветке 'TemplatedBinaryTree', шаблонизировать Бинарное дерево;
2. От ветки 'TemplatedBinaryTree' создать ветку 'SeparatedBinaryTree',
   и в ней разделить шаблонное Бинарное дерево на файлы;
3. В проекте 'ForwardList', или в отдельном проекте написать класс 'Stack',	DONE
   на базе односвязного списка;
4. В проекте 'List', или в отдельном проекте написать класс 'Quee' (очередь), 
   на базе двусвязного списка;
5. Почитать про контейнеры: https://legacy.cplusplus.com/reference/stl/
6. Вставить значение в вектор по заданному индексу	DONE
7. Добавить значение по индексу в список (std::list);
8. Добавить значение по индексу в односвязный список (std::forward_list);
	https://legacy.cplusplus.com/reference/stl/

DONE:
1. В класс BinaryTree добавить следующие методы:
	??? sum(???);	//возвращает сумму элементов дерева							DONE
	??? avg(???);	//возвращает среднее-арифметическое элементов дерева		DONE
	??? depth(???);	//возвращает глубину дерева									DONE
2. Обеспечить вызов меотодов дерева без необходимости передавать в них корень,	DONE
   например, чтобы вместо
	tree.print(tree.getRoot()); 
   можно было писать так:
	tree.print(); 
3. Деструктор дерева должен удалять все его элементы из памяти;					DONE
4. Написать метод ???erase(???), который удаляет заданное значение из дерева;	DONE
5. Оптимизировать PREFORMANCE_CHECK таким образом, чтобы производительность проверяла функция,
   и у нас небыло необходимости постоянно вызывать clock();						DONE
6. Tick-Tack (Intel)	https://www.youtube.com/watch?v=tOS3Exwhd9w&t=3s;
7. Перегрузить метод print() таким образом, чтобы он выводил все элементы дерева на заданной глубине,	DONE
   глубина считается с нуля;
8. Написать метод void true_print(), который выводит дерево как дерево;			DONE
9. Написать метод void balance(), который балансирует Бинарное дерево.

DONE:
Вынести за пределы класса методы Итераторов и методы элемента;

DONE:
1. Реализовать иерархию Итераторов;
2. Создать commit;
3. *Создать ветку 'TemplatedList2', и в этой ветке шаблонизировать двусвязный список;

DONE:
1. Проверочный код в секции HOME_WORK_1 должен заработать;
2. Обеспечить возможность вывода списка в обратном раправлении без использования метода reverse_print();

DONE:
В класс List добавить следующий методы:
	void reverse_print();		DONE
	void push_back(int Data);	DONE

	void pop_front();			DONE
	void pop_back();			DONE

	void insert(int Data, int Index)	DONE
	void erase(int Index);		DONE

DONE:
1. В класс ForwardList добавить следующие методы:
	??? Erase(???)	//удаляет элемент из списка по указанному индексу
	Написать деструктор таким образом, чтобы он очищал список перед удалением	DONE
	CopyMethods;	DONE
	MoveMethods;
2. Оптимизировать методы добавления элементов, сократив добавление элемента до 1 строки кода;			DONE
3. Написать метод ??? reverse(???), который изменяет порядок следования элементов на противоположный,	DONE
   и оптимизировать производительность списка при помощи этого метода там, где это нужно;
4. Обеспечить создание списков следующим образом:
	ForwardList list = { 3, 5, 8, 13, 21 };		DONE
5. Для класса ForwardList перегрузить оператор '+', который выполняет конкатенацию двух списков:
	ForwardList list1 = { 3, 5, 8, 13, 21 };
	ForwardList list2 = { 34, 55, 89 };
	ForwardList list3 = list1 + list2;
	for(int i:list1)cout << i << tab; cout << endl;
	for(int i:list2)cout << i << tab; cout << endl;
	for(int i:list3)cout << i << tab; cout << endl;

DONE:
В иерархию геометрических фигур добавить иерархию треугольников;

DONE:
В иерархию геометрических фигур добавить круг.
https://learn.microsoft.com/en-us/windows/win32/gdi/about-ellipses

DONE:
В Solution 'Inheritance' добавить проект 'AbstractGeometry', и в этом проекте
реализовать иерархию геометрических фигур: квадрат, прямоугольник, круг, треугольник....
Для каждой фигуры нужно вывести ее первичные свойства, например длина стороны квадрата, радиус круга....,
и вторичные свойства площадь, периметр.
Также каждую фигуру нужно нарисовать.

TODO:
0. Из фалйла "201 RAW.txt" создать файл формата 201.dhcpd:			DONE
	https://github.com/okovtun/PU_211/blob/master/Inheritance/Files/201.dhcpd
1. Сохранить группу в файл;		DONE
2. Загрузить группу из файла;
https://legacy.cplusplus.com/doc/tutorial/files/

DONE:
В проект 'Academy' добавить классы Teacher и Graduate (Дипломник).

DONE:
Классы String и Fraction разделить на файлы в соответствующих ветках.
В Классе String перед разделением сделать делегирование и инициализацию в заголовке.

DONE:
1. Литералы: https://legacy.cplusplus.com/doc/tutorial/operators/
2. Проверочный код в секции HOME_WORK_1 должен заработать:
	https://github.com/okovtun/PU_211/blob/dca9ce21d43ac9b472fe4f1e2e3b6662aa055055/IntroductionToOOP/String/main.cpp#L56
3. Для класса String перегрузить и проветрить оператор ввода с клавиатуры;
	--------------------------------------------------
4. В Solution IntroductionToOOP добавить проект TheMatrix, и в этом проекте реализовать класс Matrix,
   описывающий матрицу. 
	В классе должны быть все необходимые методы и операторы;
	Метод ??? determinant(???), который возвращает определить матрицы;
	Метод ??? inverted(???), который возвращает обращенную матрицу;


DONE:
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
1. !!!!!!!!!!!!!!!!			Выучить теорию			!!!!!!!!!!!!!!!!!!!!
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
2. Выяснить как работает метод Fraction inverted();
3. Перегрузить операторы +, -;		DONE
4. Перегрузить составные присваивания: +=, -=, *=, /=;	DONE
------------------------------------------------------------
5. Перегрузить ++/--;		DONE
6. Перегрузить операторы сравнения: ==, !=, >, <, >=, <=;	DONE
7. Перегрузить оператор ввода с клавиатуры:		DONE
	Fraction A;
	cout << "Введите простую дробь: "; cin >> A;
	cout << A << endl;
8. Проверочный код в секции HOME_WORK должен заработать;

DONE:
2. В Solution 'IntroductionToOOP' добавить проект 'Fraction', и в этом проекте
   реализовать класс 'Fraction', описывающий простую дробь. 
   В классе должны быть все необходимые методы и операторы.

	Fraction A(2,3,4);
	Fraction B(1,2);
	Fraction C = A * B;
	C.print();

DOTO:
2. Написать метод ??? distance(???), который возвращает расстояние до указанной точки;
3. Написать функцию ??? distance(???), которая возвращает расстояние между двумя точками;